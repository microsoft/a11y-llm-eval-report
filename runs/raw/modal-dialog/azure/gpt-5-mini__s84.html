<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Accessible Modal Example</title>
  <style>
    :root {
      --overlay-bg: rgba(0,0,0,0.6);
      --panel-bg: #fff;
      --radius: 8px;
      --max-width: 520px;
      --gap: 1rem;
      --transition: 180ms ease;
    }

    body {
      font-family: system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
      line-height: 1.4;
      margin: 0;
      padding: 2rem;
      background: #f7f8fb;
      color: #111;
    }

    h1 { margin-top: 0; }
    .controls { margin: 1rem 0 2rem; }

    /* Modal base
       Hidden by default using the hidden attribute (so it's not exposed to assistive tech or tab order).
    */
    .modal[hidden] {
      display: none;
    }

    /* When visible, make the element a fullscreen stacking context */
    .modal {
      position: fixed;
      inset: 0;
      z-index: 1000;
      display: flex;
      align-items: center;
      justify-content: center;
      pointer-events: none; /* allow overlay/panel to enable pointer events only */
    }

    .modal__overlay {
      position: absolute;
      inset: 0;
      background: var(--overlay-bg);
      opacity: 0;
      transition: opacity var(--transition);
      pointer-events: auto;
    }

    .modal[aria-hidden="false"] .modal__overlay {
      opacity: 1;
    }

    .modal__panel {
      position: relative;
      background: var(--panel-bg);
      max-width: var(--max-width);
      width: calc(100% - 2rem);
      border-radius: var(--radius);
      box-shadow: 0 10px 30px rgba(0,0,0,0.18);
      padding: 1.25rem 1.25rem;
      transform: translateY(8px) scale(0.995);
      opacity: 0;
      transition: transform var(--transition), opacity var(--transition);
      pointer-events: auto;
      z-index: 1;
    }

    .modal[aria-hidden="false"] .modal__panel {
      transform: translateY(0) scale(1);
      opacity: 1;
    }

    .modal__header {
      display: flex;
      align-items: start;
      gap: 0.75rem;
    }

    .modal__title {
      margin: 0;
      font-size: 1.125rem;
      flex: 1;
    }

    .modal__close {
      background: transparent;
      border: none;
      color: #444;
      font-size: 1.25rem;
      line-height: 1;
      padding: 0.25rem;
      cursor: pointer;
    }

    .modal__body { margin-top: 0.75rem; margin-bottom: 1rem; }

    .modal__footer {
      display: flex;
      gap: 0.5rem;
      justify-content: flex-end;
      margin-top: 0.5rem;
    }

    /* Prevent body scroll when modal is open */
    body.modal-open {
      overflow: hidden;
    }

    /* Minor focus styles */
    button:focus,
    a:focus {
      outline: 3px solid Highlight;
      outline-offset: 2px;
    }

    /* Demo layout */
    .box {
      background: white;
      border-radius: 8px;
      padding: 1rem;
      box-shadow: 0 6px 18px rgba(0,0,0,0.06);
      max-width: 700px;
    }

    .trigger {
      display: inline-block;
      background: #2563eb;
      color: #fff;
      padding: 0.5rem 0.75rem;
      border-radius: 6px;
      border: none;
      cursor: pointer;
      font-weight: 600;
    }
  </style>
</head>
<body>
  <div class="box" id="page-main">
    <h1>Modal dialog example</h1>
    <p>This example demonstrates an accessible modal. The open button has the class "trigger". The modal is closed by default.</p>

    <div class="controls">
      <!-- The required trigger class is on this button -->
      <button type="button" class="trigger" id="open-modal">Open modal</button>
    </div>

    <p>Background content remains interactive in markup but is hidden from assistive technology while the dialog is open.</p>
  </div>

  <!-- Modal (closed by default using hidden) -->
  <div class="modal" id="modal" role="dialog" aria-modal="true" aria-hidden="true" aria-labelledby="modal-title" aria-describedby="modal-desc" hidden>
    <div class="modal__overlay" data-overlay tabindex="-1"></div>

    <div class="modal__panel" role="document" aria-live="polite">
      <div class="modal__header">
        <h2 class="modal__title" id="modal-title">Subscribe to updates</h2>
        <button class="modal__close" type="button" aria-label="Close dialog" data-close>&times;</button>
      </div>

      <div class="modal__body" id="modal-desc">
        <p>Join our mailing list to receive the latest news and updates. This dialog traps focus while open and can be dismissed with Escape, by clicking the overlay, or the close button.</p>

        <form id="modal-form">
          <label>
            Email
            <input type="email" name="email" required placeholder="you@example.com" style="display:block;margin-top:0.35rem;padding:0.5rem;width:100%;box-sizing:border-box;">
          </label>
        </form>
      </div>

      <div class="modal__footer">
        <button type="button" data-close>Cancel</button>
        <button type="submit" form="modal-form">Subscribe</button>
      </div>
    </div>
  </div>

  <script>
    (function () {
      const modal = document.getElementById('modal');
      const overlay = modal.querySelector('[data-overlay]');
      const closeControls = modal.querySelectorAll('[data-close]');
      const focusableSelectors = [
        'a[href]',
        'area[href]',
        'input:not([disabled]):not([type="hidden"])',
        'select:not([disabled])',
        'textarea:not([disabled])',
        'button:not([disabled])',
        'iframe',
        'object',
        'embed',
        '[contenteditable]',
        '[tabindex]:not([tabindex="-1"])'
      ].join(',');

      const pageMain = document.getElementById('page-main');

      // All triggers that open the modal should have the "trigger" class (per requirement)
      const triggers = Array.from(document.querySelectorAll('.trigger'));
      let lastTrigger = null;

      // Keep state for event listeners so we can remove them cleanly
      let previouslyFocused = null;
      let boundKeydown = null;
      let boundFocusin = null;

      function openModal(triggerEl) {
        if (!modal.hasAttribute('hidden')) return;
        lastTrigger = triggerEl || document.activeElement;
        previouslyFocused = document.activeElement;

        // Show modal
        modal.removeAttribute('hidden');
        modal.setAttribute('aria-hidden', 'false');
        document.body.classList.add('modal-open');

        // Hide main content from assistive tech
        pageMain.setAttribute('aria-hidden', 'true');

        // Focus management: focus the first focusable element inside the modal
        const focusable = Array.from(modal.querySelectorAll(focusableSelectors));
        const toFocus = focusable.length ? focusable[0] : modal.querySelector('.modal__panel') || modal;
        toFocus.focus({ preventScroll: true });

        // Event listeners
        boundKeydown = handleKeydown;
        boundFocusin = handleFocusIn;
        document.addEventListener('keydown', boundKeydown);
        document.addEventListener('focusin', boundFocusin);
      }

      function closeModal() {
        if (modal.hasAttribute('hidden')) return;

        modal.setAttribute('hidden', '');
        modal.setAttribute('aria-hidden', 'true');
        document.body.classList.remove('modal-open');

        // Restore main content accessibility
        pageMain.removeAttribute('aria-hidden');

        // Remove listeners
        if (boundKeydown) document.removeEventListener('keydown', boundKeydown);
        if (boundFocusin) document.removeEventListener('focusin', boundFocusin);
        boundKeydown = null;
        boundFocusin = null;

        // Return focus to the element that opened the modal (if still in the document)
        const returnTo = lastTrigger && document.contains(lastTrigger) ? lastTrigger : previouslyFocused;
        if (returnTo && typeof returnTo.focus === 'function') {
          returnTo.focus({ preventScroll: true });
        }
      }

      function handleKeydown(e) {
        // Close on Escape
        if (e.key === 'Escape' || e.key === 'Esc') {
          e.preventDefault();
          closeModal();
          return;
        }

        // Focus trap - handle Tab/Shift+Tab
        if (e.key === 'Tab') {
          const focusable = Array.from(modal.querySelectorAll(focusableSelectors)).filter(el => el.offsetParent !== null || el === document.activeElement);
          if (focusable.length === 0) {
            // No focusable elements - keep focus on the panel
            e.preventDefault();
            modal.querySelector('.modal__panel').focus();
            return;
          }

          const first = focusable[0];
          const last = focusable[focusable.length - 1];
          if (!e.shiftKey && document.activeElement === last) {
            // Tab from last -> go to first
            e.preventDefault();
            first.focus();
          } else if (e.shiftKey && document.activeElement === first) {
            // Shift+Tab from first -> go to last
            e.preventDefault();
            last.focus();
          }
        }
      }

      function handleFocusIn(e) {
        // If focus moves outside the modal while it's open, bring it back.
        if (!modal.hasAttribute('hidden') && !modal.contains(e.target)) {
          const focusable = modal.querySelectorAll(focusableSelectors);
          (focusable[0] || modal.querySelector('.modal__panel') || modal).focus();
        }
      }

      // Open triggers
      triggers.forEach(btn => {
        btn.addEventListener('click', function (ev) {
          openModal(ev.currentTarget);
        });
      });

      // Overlay click closes
      overlay.addEventListener('click', function () {
        closeModal();
      });

      // Close buttons
      closeControls.forEach(btn => {
        btn.addEventListener('click', function () {
          closeModal();
        });
      });

      // Close on form submit (for demo, prevent default then close)
      const form = document.getElementById('modal-form');
      form.addEventListener('submit', function (ev) {
        ev.preventDefault();
        // Simulate action, then close
        closeModal();
        // In a real app you'd handle the form submission here.
      });

      // Allow opening via Enter/Space when trigger focused (native button handles this).

      // Expose for debugging (optional)
      window.demoModal = {
        open: openModal,
        close: closeModal,
        isOpen: () => !modal.hasAttribute('hidden')
      };
    })();
  </script>
</body>
</html>
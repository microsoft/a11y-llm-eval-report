<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Accessible Modal Dialog Example</title>
  <style>
    :root{
      --overlay-bg: rgba(0,0,0,0.6);
      --panel-bg: #ffffff;
      --panel-border: #2b2b2b;
      --accent: #004aad;
      --accent-contrast: #ffffff;
      --danger: #b00020;
      --radius: 8px;
      --shadow: 0 10px 30px rgba(0,0,0,0.35);
      --focus-ring: 3px solid #ffbf47;
    }

    html,body{
      height:100%;
      margin:0;
      font-family: system-ui,-apple-system,Segoe UI,Roboto,"Helvetica Neue",Arial;
      background:#f6f7f9;
      color:#111;
      -webkit-font-smoothing:antialiased;
    }

    header{
      padding:1rem;
      background:linear-gradient(90deg,#eef4ff,#fff);
      border-bottom:1px solid #e6e9ef;
    }

    main{
      max-width:900px;
      margin:2rem auto;
      padding:1rem;
    }

    .trigger{
      display:inline-block;
      padding:0.6rem 1rem;
      font-size:1rem;
      border-radius:6px;
      border:2px solid var(--accent);
      background:var(--accent);
      color:var(--accent-contrast);
      cursor:pointer;
    }

    .trigger:focus{
      outline-offset:3px;
      box-shadow:0 0 0 4px rgba(0,74,173,0.16);
    }

    /* Overlay and modal */
    .overlay {
      position: fixed;
      inset: 0;
      display:flex;
      align-items: center;
      justify-content: center;
      background: var(--overlay-bg);
      z-index: 1000;
    }
    .overlay[hidden]{
      display:none;
    }

    .modal {
      background: var(--panel-bg);
      border: 1px solid var(--panel-border);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      max-width: 600px;
      width: calc(100% - 2rem);
      margin: 1rem;
      padding: 1rem;
    }

    .modal:focus{
      outline: none;
    }

    .modal-header{
      display:flex;
      align-items:start;
      justify-content:space-between;
      gap:1rem;
    }

    h2{
      margin:0;
      font-size:1.25rem;
    }

    .modal-body{
      margin-top:1rem;
      color:#222;
      line-height:1.4;
    }

    .modal-footer{
      margin-top:1.25rem;
      display:flex;
      gap:.5rem;
      justify-content:flex-end;
    }

    .btn {
      padding:0.5rem 0.85rem;
      border-radius:6px;
      border:2px solid transparent;
      background:#efefef;
      cursor:pointer;
      font-size:0.95rem;
    }
    .btn:focus{
      outline: none;
      box-shadow: var(--focus-ring);
    }

    .btn.primary{
      background:var(--accent);
      color:var(--accent-contrast);
      border-color:var(--accent);
    }

    .btn.negative{
      background:var(--danger);
      color:var(--accent-contrast);
      border-color:var(--danger);
    }

    /* Make focus outlines highly visible for keyboard users */
    :focus{
      outline-offset:3px;
    }

    /* Ensure focusable form controls are clear */
    input[type="text"]{
      padding:0.5rem;
      border-radius:6px;
      border:1px solid #cfd6e3;
      width:100%;
      box-sizing:border-box;
      font-size:1rem;
    }

    /* Visually hidden utility */
    .visually-hidden {
      position: absolute !important;
      height: 1px; width: 1px;
      overflow: hidden;
      clip: rect(1px, 1px, 1px, 1px);
      white-space: nowrap;
    }
  </style>
</head>
<body>
  <a class="visually-hidden" href="#main">Skip to main content</a>
  <header>
    <h1 style="margin:0; font-size:1rem;">Modal Dialog Component Demo</h1>
  </header>

  <main id="main" tabindex="-1" aria-label="Main content">
    <section aria-labelledby="intro">
      <h2 id="intro">Example: Accessible Modal</h2>
      <p>
        This example shows a keyboard- and screen reader-friendly modal dialog.
        The dialog is closed by default. The button below has the class "trigger".
      </p>

      <p>
        <button class="trigger" id="openDialog">Open settings dialog</button>
      </p>
    </section>
  </main>

  <!-- Modal overlay is hidden by default -->
  <div class="overlay" id="overlay" hidden>
    <div class="modal" id="dialog"
         role="dialog"
         aria-modal="true"
         aria-labelledby="dialogTitle"
         aria-describedby="dialogDesc"
         tabindex="-1">
      <div class="modal-header">
        <h2 id="dialogTitle">Settings</h2>
        <button id="closeBtn" class="btn" aria-label="Close dialog" title="Close dialog">
          âœ•
        </button>
      </div>

      <div class="modal-body" id="dialogDesc">
        <p>Update display name and save changes. You can close this dialog with the Escape key, the close button, or the Cancel button.</p>

        <form id="settingsForm">
          <label for="displayName">Display name</label>
          <input id="displayName" name="displayName" type="text" value="Alex User" autocomplete="name" required />
        </form>
      </div>

      <div class="modal-footer">
        <button type="button" id="cancelBtn" class="btn">Cancel</button>
        <button type="button" id="saveBtn" class="btn primary">Save</button>
      </div>
    </div>
  </div>

  <script>
    (function () {
      // Elements
      const trigger = document.querySelector('.trigger');
      const overlay = document.getElementById('overlay');
      const dialog = document.getElementById('dialog');
      const closeBtn = document.getElementById('closeBtn');
      const cancelBtn = document.getElementById('cancelBtn');
      const saveBtn = document.getElementById('saveBtn');
      const main = document.getElementById('main');

      // Keep track of the last focused element to restore focus after close.
      let lastFocusedElement = null;

      // Utility: find focusable elements inside a container
      function getFocusable(container) {
        return Array.from(
          container.querySelectorAll(
            'a[href], area[href], input:not([disabled]):not([type="hidden"]), select:not([disabled]), textarea:not([disabled]), button:not([disabled]), iframe, [tabindex]:not([tabindex="-1"]), [contenteditable]'
          )
        ).filter(el => el.offsetWidth > 0 || el.offsetHeight > 0 || el === document.activeElement);
      }

      // Open dialog
      function openDialog() {
        if (!overlay.hasAttribute('hidden')) return;
        lastFocusedElement = document.activeElement;
        overlay.removeAttribute('hidden');
        // Hide main content from assistive tech
        main.setAttribute('aria-hidden', 'true');
        // Prevent page scroll when modal is open
        document.documentElement.style.overflow = 'hidden';
        document.body.style.overflow = 'hidden';

        // Set focus to the dialog or the first focusable element inside
        const focusable = getFocusable(dialog);
        if (focusable.length) {
          focusable[0].focus();
        } else {
          dialog.focus();
        }

        // Add listeners
        document.addEventListener('keydown', onKeyDown);
        overlay.addEventListener('click', onOverlayClick);
      }

      // Close dialog
      function closeDialog() {
        if (overlay.hasAttribute('hidden')) return;
        overlay.setAttribute('hidden', '');
        main.removeAttribute('aria-hidden');
        document.documentElement.style.overflow = '';
        document.body.style.overflow = '';

        // Remove listeners
        document.removeEventListener('keydown', onKeyDown);
        overlay.removeEventListener('click', onOverlayClick);

        // Restore focus to what had it before
        if (lastFocusedElement && typeof lastFocusedElement.focus === 'function') {
          lastFocusedElement.focus();
        } else {
          trigger.focus();
        }
      }

      // Key handling: Escape to close, Tab to trap focus
      function onKeyDown(e) {
        if (e.key === 'Escape' || e.key === 'Esc') {
          // Close on Escape
          e.preventDefault();
          closeDialog();
          return;
        }

        if (e.key === 'Tab') {
          // Trap focus inside dialog
          const focusable = getFocusable(dialog);
          if (focusable.length === 0) {
            // No focusable elements: keep focus on dialog container
            e.preventDefault();
            dialog.focus();
            return;
          }
          const first = focusable[0];
          const last = focusable[focusable.length - 1];
          if (e.shiftKey) {
            if (document.activeElement === first || document.activeElement === dialog) {
              e.preventDefault();
              last.focus();
            }
          } else {
            if (document.activeElement === last) {
              e.preventDefault();
              first.focus();
            }
          }
        }
      }

      // Click on overlay outside the dialog content closes the dialog
      function onOverlayClick(e) {
        if (e.target === overlay) {
          closeDialog();
        }
      }

      // Actions
      trigger.addEventListener('click', openDialog);

      // Allow Enter and Space on trigger (button handles it natively, but ensure keyboard activates)
      trigger.addEventListener('keydown', function (e) {
        if (e.key === 'Enter' || e.key === ' ') {
          e.preventDefault();
          openDialog();
        }
      });

      closeBtn.addEventListener('click', closeDialog);
      cancelBtn.addEventListener('click', closeDialog);

      saveBtn.addEventListener('click', function () {
        // Simulate saving settings
        // For accessibility, announce result via alert role or visually
        const displayName = document.getElementById('displayName').value;
        // Use a simple alert dialog via window.alert for this demo environment; in real apps, prefer non-blocking notification with aria-live
        // eslint-disable-next-line no-alert
        alert('Saved display name: ' + displayName);
        closeDialog();
      });

      // Prevent focus from moving outside when clicked with mouse (optional protection)
      dialog.addEventListener('keydown', function (e) {
        // If user presses Enter in text field, do not unexpectedly close the dialog
        if (e.key === 'Enter' && e.target.tagName.toLowerCase() !== 'textarea') {
          // Let Enter submit button if focused; otherwise do nothing special
          const active = document.activeElement;
          if (active && active.id === 'saveBtn') {
            // natural behavior
            return;
          }
        }
      });

      // Ensure focus styles are always visible for keyboard users
      // This small script adds a class to body when using keyboard navigation (Tab)
      (function keyboardFocusDetection() {
        const body = document.body;
        function handleFirstTab(e) {
          if (e.key === 'Tab') {
            body.classList.add('user-is-tabbing');
            window.removeEventListener('keydown', handleFirstTab);
            window.addEventListener('mousedown', handleMouseDownOnce);
          }
        }
        function handleMouseDownOnce() {
          body.classList.remove('user-is-tabbing');
          window.removeEventListener('mousedown', handleMouseDownOnce);
          window.addEventListener('keydown', handleFirstTab);
        }
        window.addEventListener('keydown', handleFirstTab);
      })();

      // Accessibility: Ensure the overlay is not announced when hidden by adding aria-hidden when hidden
      const observer = new MutationObserver(function () {
        if (overlay.hasAttribute('hidden')) {
          overlay.setAttribute('aria-hidden', 'true');
        } else {
          overlay.removeAttribute('aria-hidden');
        }
      });
      observer.observe(overlay, { attributes: true, attributeFilter: ['hidden'] });

      // Initialize aria-hidden on overlay
      if (overlay.hasAttribute('hidden')) {
        overlay.setAttribute('aria-hidden', 'true');
      }
    })();
  </script>
</body>
</html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Accessible Modal Example</title>
  <style>
    :root{
      --overlay-bg: rgba(0,0,0,0.6);
      --panel-bg: #fff;
      --max-width: 540px;
      --radius: 8px;
      --transition: 200ms cubic-bezier(.2,.9,.2,1);
    }

    html,body{
      height:100%;
      margin:0;
      font-family: system-ui,-apple-system,Segoe UI,Roboto,"Helvetica Neue",Arial;
      background: #f4f6f8;
      color:#111827;
      -webkit-font-smoothing:antialiased;
      -moz-osx-font-smoothing:grayscale;
    }

    /* Page content */
    .page {
      min-height:100vh;
      display:flex;
      align-items:center;
      justify-content:center;
      padding:32px;
    }
    .card {
      background: white;
      padding:24px;
      border-radius:12px;
      box-shadow: 0 6px 20px rgba(16,24,40,0.08);
      max-width:760px;
      width:100%;
      text-align:center;
    }

    button {
      appearance:none;
      border:0;
      background:#2563eb;
      color:white;
      padding:10px 16px;
      border-radius:8px;
      font-weight:600;
      cursor:pointer;
      box-shadow: 0 2px 8px rgba(37,99,235,0.18);
    }
    button:focus {
      outline: 3px solid rgba(37,99,235,0.2);
      outline-offset: 3px;
    }

    /* Modal base */
    .modal {
      position: fixed;
      inset: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 60;
      pointer-events: none;  /* prevent clicks when hidden */
    }

    .modal__overlay {
      position:absolute;
      inset:0;
      background: var(--overlay-bg);
      opacity:0;
      transition: opacity var(--transition);
      will-change: opacity;
      pointer-events: auto;
    }

    .modal__panel {
      position: relative;
      background: var(--panel-bg);
      width: calc(100% - 32px);
      max-width: var(--max-width);
      border-radius: var(--radius);
      box-shadow: 0 10px 30px rgba(2,6,23,0.2);
      transform: translateY(12px) scale(.98);
      opacity:0;
      transition: transform var(--transition), opacity var(--transition);
      z-index: 2;
      pointer-events: auto;
      padding: 20px;
    }

    .modal__header {
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:12px;
    }
    .modal__title {
      margin:0;
      font-size:18px;
      font-weight:700;
      color:#0f172a;
    }
    .modal__close {
      background:transparent;
      color:#374151;
      border-radius:6px;
      padding:6px;
      border:1px solid transparent;
      cursor:pointer;
    }
    .modal__close:focus {
      outline: 3px solid rgba(99,102,241,0.18);
      outline-offset:3px;
    }

    .modal__body {
      margin-top:14px;
      font-size:15px;
      color:#334155;
      line-height:1.45;
    }

    .modal.show {
      pointer-events: auto;
    }
    .modal.show .modal__overlay {
      opacity:1;
    }
    .modal.show .modal__panel {
      transform: translateY(0) scale(1);
      opacity:1;
    }

    /* Visually hidden for a11y */
    .sr-only {
      position: absolute !important;
      width: 1px; height: 1px;
      padding: 0; margin: -1px;
      overflow: hidden; clip: rect(0,0,0,0);
      white-space: nowrap; border: 0;
    }

    /* Small responsive tweaks */
    @media (max-width:420px){
      .modal__panel { padding:16px; }
      .modal__title { font-size:16px; }
    }
  </style>
</head>
<body>
  <main id="main" class="page" tabindex="-1">
    <div class="card" role="region" aria-label="Demo content">
      <h1 style="margin-top:0">Accessible Modal Demo</h1>
      <p style="color:#475569">This page demonstrates a modal dialog. The open button below has the class "trigger". The modal is closed by default.</p>
      <div style="display:flex; gap:12px; justify-content:center; margin-top:18px;">
        <button class="trigger" type="button">Open Modal</button>
        <button class="trigger" type="button" aria-label="Open modal alternative">Another Trigger</button>
      </div>
    </div>
  </main>

  <!-- Modal (closed by default) -->
  <div id="modal" class="modal" role="dialog" aria-modal="true" aria-labelledby="modal-title" aria-describedby="modal-desc" hidden>
    <div class="modal__overlay" data-close="overlay"></div>

    <div class="modal__panel" role="document" tabindex="-1">
      <header class="modal__header">
        <h2 id="modal-title" class="modal__title">Example Modal</h2>
        <button class="modal__close" type="button" aria-label="Close dialog">&times;</button>
      </header>

      <div id="modal-desc" class="modal__body">
        <p>This dialog demonstrates an accessible modal with focus trapping, Escape-to-close, and closing by clicking the overlay. It is hidden by default and opened by any button with the class "trigger".</p>
        <p style="margin-top:12px">Try tabbing through elements; focus will remain inside the dialog while open.</p>
        <div style="margin-top:16px; display:flex; gap:8px; justify-content:flex-end;">
          <button type="button" class="confirm">Confirm</button>
          <button type="button" class="cancel">Cancel</button>
        </div>
      </div>
    </div>
  </div>

  <script>
    (function(){
      const modal = document.getElementById('modal');
      const panel = modal.querySelector('.modal__panel');
      const overlay = modal.querySelector('.modal__overlay');
      const closeBtn = modal.querySelector('.modal__close');
      const main = document.getElementById('main');
      const triggers = Array.from(document.querySelectorAll('.trigger'));

      let previouslyFocusedElement = null;

      // Utility: find focusable elements within the modal
      const FOCUSABLE_SELECTORS = [
        'a[href]:not([tabindex="-1"]):not([inert])',
        'area[href]',
        'input:not([type="hidden"]):not([disabled]):not([tabindex="-1"])',
        'select:not([disabled]):not([tabindex="-1"])',
        'textarea:not([disabled]):not([tabindex="-1"])',
        'button:not([disabled]):not([tabindex="-1"])',
        'iframe',
        'object',
        'embed',
        '[contenteditable]',
        '[tabindex]:not([tabindex="-1"])'
      ].join(',');

      function getFocusableElements() {
        return Array.from(panel.querySelectorAll(FOCUSABLE_SELECTORS))
          .filter(el => !!(el.offsetWidth || el.offsetHeight || el.getClientRects().length));
      }

      function openModal(triggerEl = null) {
        if (!modal.hasAttribute('hidden')) return;
        previouslyFocusedElement = triggerEl || document.activeElement;

        // Show modal
        modal.removeAttribute('hidden');
        requestAnimationFrame(() => modal.classList.add('show'));

        // Hide main content from assistive tech and set inert if supported
        main.setAttribute('aria-hidden', 'true');
        if ('inert' in HTMLElement.prototype) main.inert = true;

        // Prevent body scroll
        document.body.style.overflow = 'hidden';

        // Focus management
        const focusables = getFocusableElements();
        const first = focusables.length ? focusables[0] : panel;
        first.focus();

        // Attach keyboard listener
        document.addEventListener('keydown', handleKeydown, true);
        // Also stop page from being tabbable outside; we rely on focus trap listener
      }

      function closeModal() {
        if (modal.hasAttribute('hidden')) return;

        modal.classList.remove('show');

        // Wait for transition to finish before hiding attribute and restoring states.
        const transitionDuration = 220; // ms, should match CSS transition timing a bit
        setTimeout(() => {
          modal.setAttribute('hidden', '');
          // restore main accessibility
          main.removeAttribute('aria-hidden');
          if ('inert' in HTMLElement.prototype) main.inert = false;
          // restore scroll
          document.body.style.overflow = '';
          // restore focus
          if (previouslyFocusedElement && typeof previouslyFocusedElement.focus === 'function') {
            previouslyFocusedElement.focus();
          }
          previouslyFocusedElement = null;
        }, transitionDuration);

        document.removeEventListener('keydown', handleKeydown, true);
      }

      function handleKeydown(e) {
        if (e.key === 'Escape') {
          e.preventDefault();
          closeModal();
          return;
        }

        if (e.key === 'Tab') {
          // Focus trap
          const focusables = getFocusableElements();
          if (focusables.length === 0) {
            // ensure panel itself is focusable
            e.preventDefault();
            panel.focus();
            return;
          }
          const first = focusables[0];
          const last = focusables[focusables.length - 1];
          const active = document.activeElement;

          if (e.shiftKey) {
            // Shift + Tab
            if (active === first || active === panel) {
              e.preventDefault();
              last.focus();
            }
          } else {
            // Tab
            if (active === last) {
              e.preventDefault();
              first.focus();
            }
          }
        }
      }

      // Open handlers for triggers
      triggers.forEach(btn => {
        btn.addEventListener('click', (e) => {
          openModal(e.currentTarget);
        });
      });

      // Close handlers
      closeBtn.addEventListener('click', closeModal);
      overlay.addEventListener('click', (e) => {
        // Close only when clicked directly on overlay
        if (e.target === overlay) closeModal();
      });

      // Example internal controls
      modal.addEventListener('click', (e) => {
        // close on clicking cancel
        if (e.target && e.target.classList.contains('cancel')) {
          closeModal();
        }
        if (e.target && e.target.classList.contains('confirm')) {
          // Simulate confirm action then close
          // (In real app you'd run some action)
          closeModal();
          // Optionally give feedback
          previouslyFocusedElement = document.querySelector('.trigger');
        }
      });

      // Accessibility: if focus moves outside while modal open, bring it back (extra safeguard)
      document.addEventListener('focusin', (e) => {
        if (modal.hasAttribute('hidden')) return;
        if (!modal.contains(e.target)) {
          // Move focus back into modal
          const focusables = getFocusableElements();
          const toFocus = focusables.length ? focusables[0] : panel;
          toFocus.focus();
        }
      });

      // Ensure modal panel has a sensible tabindex for focusing
      if (!panel.hasAttribute('tabindex')) panel.setAttribute('tabindex', '-1');

      // Safety: close on unload/resets
      window.addEventListener('beforeunload', () => {
        if (!modal.hasAttribute('hidden')) closeModal();
      });
    })();
  </script>
</body>
</html>